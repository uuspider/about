---
layout: post
title: Image processing & PIL
---

<script type="text/javascript" src="{{site.baseurl}}/MathJax-2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

## Image Processing & PIL

参考：[Keras Documentation][ref1]{:target="_blank"}, [Keras文档][ref2]{:target="_blank"}, [卷积神经网络][ref3]{:target="_blank"}, [机器学习][ref4]{:target="_blank"}

[ref1]:https://keras.io/
[ref2]:http://keras-cn.readthedocs.io/en/latest/
[ref3]:https://www.zybuluo.com/hanbingtao/note/485480
[ref4]:http://www.jianshu.com/p/28f02bb59fe5

<h2 id="top"></h2>

***

*   [PIL安装](#setup)
*   [图像模式](#mode)
    *   [神经元](#perceptron)


***

## 安装 {#setup}

    $ pip install -I --no-cache-dir -v Pillow

或

    $ sudo apt-get install python-imaging

***

## 图像模式 {#mode}

### 1

二值图像，非黑即白，每个像素存储为8bit，0为黑，255为白。

### L

灰度图像，每个像素存储为8bit，0为黑，255为白。从RGB转为L的公式为：

L = (299R+587G+114B)/1000  (取整数)

### P

彩色图像，每个像素存储为8bit，色值从调色板中查询(使用调色板映射到其它模式)。

### RGB

真彩色图像，每个像素存储为3×8bit，依次用8bit表示红、绿、蓝通道。

### RGBA

有透明通道的真彩色图像，每个像素存储为4×8bit，依次为红、绿、蓝、透明通道，255表示完全不透明。

### CMYK

彩色图像，每个像素存储为4×8bit，依次为Cyan青、Magenta品红、Yellow黄、黑KeyPlate，即印刷三原色加黑色。

C=255-R, M=255-G, Y=255-B, K=0

### YCbCr

彩色视频，每个像素存储为3×8bit，依次为Y亮度、Cb蓝色色度、Cr红色色度。

Y = 0.257R+0.504G+0.098B+16

Cb = -0.148R-0.291G+0.439B+128

Cr = 0.439R-0.368G-0.071B+128

### I

整型灰度图像，每个像素存储为32bit，0为黑，255为白。公式同“L”。

### F

浮点灰度图像，每个像素存储为32bit，0为黑，255为白。公式同“L”。


向RGB转换时，1、L、I、F直接将色值复制为三通道，P通过逆向查询RGB值，RGBA、CMYK丢弃第四通道，YCbCr按照公式进行转换。

**[[TOP](#top)]**

***

## Image实例属性

    from PIL import Image

`lena.format`： 图像格式，由PIL创建的图像为None。

`lena.mode`： 图像模式。

`lena.size`： 元组(w, h)。

`lena.palette`： "P"模式下的palette实例或None。

`lena.info`： 字典，包含图像属性信息。

**[[TOP](#top)]**

***

## Image类的函数

`Image.new("RGB", (128,128), "#FF0000")`： 创建128×128的红色图像，color为十六进制色符，或red、blue等颜色，默认为0。

`Image.open('filepath/filename', 'r')`： 打开图像，mode必须为'r'或不设置。

`Image.blend(lena_1, lena_2, alpha)`： 叠加图像，alpha为透明度，当alpha=0时为lena_1，alpha=1时为lena_2，计算公式为：lena_1×(1.0-alpha)+lena_2×alpha。

`Image.composite(lena_1, lena_2, mask)`： 叠加图像，mask为蒙版图像，作为透明度，其模式可为1、L或RGBA。

`Image.eval(lena, fun)`： 使用fun函数处理lena中的每一个像素，若有多个通道，每个通道值都会处理一次，如：

    def fun(x):
        return x*0.5
    Image.eval(lena, fun)

`Image.merge("RGB", lena)`： 使用单通道创建图像，如：

    r1, g1, b1 = lena_1.split()
    r2, g2, b2 = lena_2.split()
    lena = [r1, g2, b2] # 或(r1, g2, b2)
    Image.merge("RGB", lena)

**[[TOP](#top)]**

***

## Image实例方法

`lena.convent(mode)`： 将图片转换为mode模式。

`lena.convent(mode, [dither|palette|colors])`： 使用调色板的转换。

`lena.convent("L|RGB", matrix)`： 带矩阵的模式转换，只适用于L或RGB图像，matrix为4~16元组。

`lena.copy()`： 复制图像。

`lena.crop(box)`： 裁剪box区域，box=(x0, y0, x1, y1)。PIL使用笛卡尔像素坐标系统，坐标(0, 0)位于左上角。注意：坐标值表示像素的角；位于坐标(0, 0)处的像素的中心实际上位于(0.5, 0.5)。

`lena.draft(mode, size)`： 按照给定的模式和尺寸修改原图。

`lena.filter(FILTER)`： 使用FILTER过滤器，详细用法可查看[ImageFilter模块文档](#filter)。

`lena.getbands()`： 返回类似于("R", "G", "B")的元组。

`lena.getbbox()`： 返回一个元组(x0, y0, x1, y1)，包围非零像素区域。

`lena.getcolors(maxcolors)`： 返回一个列表，元素是元组(count, color)，包含了图像中的所有颜色。maxcolors默认为256，若超出则返回空。

`lena.getextrema()`： 返回类似于((0, 255), (0, 254), (0, 255))三通道的极值。

`lena.getpixel((x, y))`： 返回(x, y)处的像素信息。

`lena.histogram()`： 返回一个直方图的列表，值为像素数量。

`lena.paste(image, box)`： 将image粘贴到lena上，box为空(即(0, 0))或二元组或四元组；image的模式会转换为lena的模式。

`lena.paste(color, box)`： 纯色填充，对于单通道的lena，color为单值，对于多通道的lena，color为一个元组。

`lena.paste(image, box, mask)`： 将image作为蒙板粘贴，其模式可为1、L或RGBA，若mask为0，则image完全透明，若mask为255，则image完全不透明。

`lena.paste(color, box, mask)`： 纯色蒙板覆盖。

`lena.point(table|function, mode)`： 按照table或function处理每个像素点。

`lena.putalpha(band)`： 将给定的通道复制到alpha层，lena必须为RGBA，band必须为L或1模式的图像或一个整数的颜色值。

`lena.putpixel((x, y), (r, g, b))`： 修改(x, y)处的像素值。

`lena.resize(size, filter)`：　size是一个二元组(w, h)；filter为NEAREST，　BILINEAR，　BICUBIC，　ANTIALIAS之一，默认为NEAREST。

`lena.rotate(angle, filter=NEAREST, expand=0)`：　angle为顺时针旋转；若expand为1(True)则输出图像大小会自动调整；若expand为0(False)，则图像保持原大小，默认为1。

`lena.save(outfile, format, options)`：　若不指定format，则根据文件名判断格式。

`lena.seek(frame)`：　frame为帧数，即查找gif的第n帧。

`lena.show()`：　*nix中保持为ppm文件，调用xv显示，win中保持为bmp文件。

`lena.split()`：　返回一个元组，由各通道组成，可用于将单个通道形成一个图像。

`lena.tell()`：　返回当前帧位置，从0开始计算。

`lena.thumbnail(size, filter)`：　返回缩略图(直接修改原图)。

`lena.tobitmap()`：　返回转换为X11的bitmap图像。

`lena.tostring()`：　返回一个标准raw编码的字符串。

`lena.transform(size, method, data, filter)`：　method包括裁剪(EXTENT)、仿射(AFFINE)、拉伸(QUAD)、映射(MESH)、透视(PERSPECTIVE)，如：

    lena.transform((300, 300), Image.PERSPECTIVE, (1, 2, 3, 2, 1, 6, 1, 2))

`lena.tanspose(method)`：　method包括FLIP_LEFT(RIGHT, TOP, BOTTOM), ROTATE_90(180, 270)。

`lena.verify()`：　检查文件是否损坏。

**[[TOP](#top)]**

***

## ImageFilter过滤器　{#filter}

    from PIL import ImageFilter

`ImageFilter.BLUR`：　模糊，如`lena.filter(ImageFilter.BLUR)`。

`ImageFilter.CONTOUR`：　提取轮廓信息。

`ImageFilter.DETAIL`：　细节增强，突出图像中的细节。

`ImageFilter.EDGE_ENHANCE`：　边缘增强，突出、加强、改善不同灰度区域之间的边界和轮廓。

`ImageFilter.EDGE_ENHANCE_MORE`：　深度边缘增强。

`ImageFilter.EMBOSS`：　浮雕。

`ImageFilter.FIND_EDGES`：　寻找边缘信息。

`ImageFilter.SMOOTH`：　平滑，突出图像的宽大区域、低频成分、主干部分或抑制图像噪声和干扰高频成分，使图像亮度平缓渐变，减小突变梯度。

`ImageFilter.SMOOTH_MORE`：　深度平滑。

`ImageFilter.SHARPEN`：　锐化，补偿图像的轮廓，增强图像的边缘及灰度跳变的部分，使图像更清晰。

**[[TOP](#top)]**

***

## ImageFilter类的函数　{#filter_fun}

`ImageFilter.Kernel(size, kernel, scale=None, offset=0)`：　生成一个(size×size)的卷积核，size可取3或5，对应的kernel为9或25个整数或浮点数的序列。如果设置了scale，卷积核作用于每个像素值之后的数据需要除以scale；如果设置了offset，该值将加到卷积核作用的结果上，再除以scale。如：

    lena.filter(ImageFilter.Kernel((3,3), (1,1,1,0,0,0,2,0,2)))

`ImageFilter.RankFilter(size, rank)`：　对图像中以某个像素点为中心的(size×size)区域中的像素值进行排序，选择**第rank**的像素值更新当前像素点。

`ImageFilter.MinFilter(size=3)`：　从图像中以某个像素点为中心的(size×size)区域中选择**最小**的像素值更新当前像素点。

`ImageFilter.MedianFilter(size=3)`：　从图像中以某个像素点为中心的(size×size)区域中选择所有像素的**中值**更新当前像素点。

`ImageFilter.MaxFilter(size=3)`：　从图像中以某个像素点为中心的(size×size)区域中选择**最大**的像素值更新当前像素点。

`ImageFilter.ModeFilter(size=3)`：　从图像中以某个像素点为中心的(size×size)区域中选择**出现次数最多**的像素值更新当前像素点，如果所有像素出现频率相同，则使用原始像素值。





**[[TOP](#top)]**

***
