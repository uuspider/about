---
layout: default
title: grep & encoding
---

grep 是 Linux 中一个用来进行对文本内容进行搜索和匹配的命令行工具，是 "Global Regular Expression Print" 的简写，顾名思义，grep 与 "Regular Expression" 是密不可分的，学习 grep ，关键就是掌握正则表达式的用法。

grep [OPTIONS] PATTERN [FILE...]

-a 以文本文件方式搜索
-c 计算找到的符合行的次数
-i 忽略大小写
-n 输出行号
-v 反向选择，输出不含搜索字符串的行


正则表达式只是一种表示法,只要工具支持这种表示法， 那么该工具就可以处理正则表达式的字符串。vim、grep、awk 、sed 都支持正则表达式，也正是因为由于它们支持正则，才显得它们强大；在以前上班的公司里，由于公司是基于web的服务型网站(nginx)，对正则的需求比 较大，所以也花了点时间研究正则，特与大家分享下：

1基础正则表达式

1
搜索有the的行,并输出行号
$grep -n 'the' regular_express.txt
搜 索没有the的行,并输出行号
$grep -nv 'the' regular_express.txt

2 利 用[]搜索集合字符
[] 表示其中的某一个字符 ，例如[ade] 表示a或d或e
woody@xiaoc:~/tmp$ grep -n 't[ae]st' regular_express.txt 
8:I can't finish the test.
9:Oh! the soup taste good!

可以用^符号做[]内的前缀，表示除[]内的字符之外的字 符。
比如搜索oo前没有g的字符串所在的行. 使用 '[^g]oo' 作搜索字符串
woody@xiaoc:~/tmp$ grep -n '[^g]oo' regular_express.txt 
2:apple is my favorite food.
3:Football game is not use feet only.
18:google is the best tools for search keyword.
19:goooooogle yes!

[] 内可以用范围表示，比如[a-z] 表示小写字母,[0-9] 表示0~9的数字, [A-Z] 则是大写字母们。[a-zA-Z0-9]表示所有数字与英文字符。 当然也可以配合^来排除字符。
搜索包含数字的行
woody@xiaoc:~/tmp$ grep -n '[0-9]' regular_express.txt 
5:However ,this dress is about $ 3183 dollars.
15:You are the best is menu you are the no.1.

行首与行尾字符 ^ $. ^ 表示行的开头，$表示行的结尾( 不是字符，是位置）那么‘^$’ 就表示空行,因为只有
行首和行尾。
这里^与[]里面使用的^意义不同。它表示^后面的串是在行的开头。
比如搜索the在开头的行
woody@xiaoc:~/tmp$ grep -n '^the' regular_express.txt 
12:the symbol '*' is represented as star.

搜索以小写字母开头的行
woody@xiaoc:~/tmp$ grep -n '^[a-z]' regular_express.txt 
2:apple is my favorite food.
4:this dress doesn't fit me.
10:motorcycle is cheap than car.
12:the symbol '*' is represented as star.
18:google is the best tools for search keyword.
19:goooooogle yes!
20:go! go! Let's go.
woody@xiaoc:~/tmp$ 

搜索开头不是英文字母的行
woody@xiaoc:~/tmp$ grep -n '^[^a-zA-Z]' regular_express.txt 
1:"Open Source" is a good mechanism to develop programs.
21:#I am VBird
woody@xiaoc:~/tmp$ 

$表示它前面的串是在行的结尾，比如 '/.' 表示 . 在一行的结尾
搜索末尾是.的行
woody@xiaoc:~/tmp$ grep -n '/.$' regular_express.txt //. 是正则表达式的特殊符号，所以要用/转义
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
4:this dress doesn't fit me.
5:However ,this dress is about $ 3183 dollars.
6:GNU is free air not free beer.
.....

注意在MS的系统下生成的文本文件，换行会加上一个 ^M 字符。所以最后的字符会是隐藏的^M ,在处理Windows
下面的文本时要特别注意！
可以用cat dos_file | tr -d '/r' > unix_file 来删除^M符号。 ^M==/r

那么'^$' 就表示只有行首行尾的空行拉！
搜索空行
woody@xiaoc:~/tmp$ grep -n '^$' regular_express.txt 
22:
23:
woody@xiaoc:~/tmp$ 

搜索非空行
woody@xiaoc:~/tmp$ grep -vn '^$' regular_express.txt 
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
4:this dress doesn't fit me.
..........

任意一个字符. 与重复字符 *

在bash中*代表通配符，用来代表任意个 字符，但是在正则表达式中，他含义不同，*表示有0个或多个 某个字符。
例如 oo*, 表示第一个o一定存在，第二个o可以有一个或多个，也可以没有，因此代表至少一个o.

点. 代表一个任意字符，必须存在。 g??d 可以用 'g..d' 表示。 good ,gxxd ,gabd .....都符合。

woody@xiaoc:~/tmp$ grep -n 'g..d' regular_express.txt 
1:"Open Source" is a good mechanism to develop programs.
9:Oh! the soup taste good!
16:The world is the same with 'glad'.
woody@xiaoc:~/tmp$ 

搜索两个o以上的字符串
woody@xiaoc:~/tmp$ grep -n 'ooo*' regular_express.txt //前两个o一定存在，第三个o可没有，也可有多个。
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
9:Oh! the soup taste good!
18:google is the best tools for search keyword.
19:goooooogle yes!

搜索g开头和结尾，中间是至少一个o的字符串，即gog, goog....gooog...等
woody@xiaoc:~/tmp$ grep -n 'goo*g' regular_express.txt 
18:google is the best tools for search keyword.
19:goooooogle yes!

搜索g开头和结尾的字符串在的行
woody@xiaoc:~/tmp$ grep -n 'g.*g' regular_express.txt     // .*表示 0个或多个任意字符
1:"Open Source" is a good mechanism to develop programs.
14:The gd software is a library for drafting programs.
18:google is the best tools for search keyword.
19:goooooogle yes!
20:go! go! Let's go.


限定连续重复字符的范围 { } 
. * 只能限制0个或多个， 如果要确切的限制字符重复数量，就用{范围} 。范围是数字用,隔开 2,5 表示2~5个,
2表示2个，2, 表示2到更多个
注意，由于{ }在SHELL中有特殊意义，因此作为正则表达式用的时候要用/转义一下。

搜索包含两个o的字符串的行。
woody@xiaoc:~/tmp$ grep -n 'o/{2/}' regular_express.txt 
1:"Open Source" is a good mechanism to develop programs.
2:apple is my favorite food.
3:Football game is not use feet only.
9:Oh! the soup taste good!
18:google is the best tools for search keyword.
19:goooooogle yes!

搜索g后面跟2~5个o,后面再跟一个g的字符串的行。
woody@xiaoc:~/tmp$ grep -n 'go/{2,5/}g' regular_express.txt 
18:google is the best tools for search keyword.


搜索包含g后面跟2个以上o,后面再跟g的行。。
woody@xiaoc:~/tmp$ grep -n 'go/{2,/}g' regular_express.txt 
18:google is the best tools for search keyword.
19:goooooogle yes!


注意，相让[]中的^ － 不表现特殊意义，可以放在[]里面内容的后面。
'[^a-z/.!^ -]' 表示没有小写字母，没有. 没有!, 没有空格，没有- 的 串，注意[]里面有个小空格。

另外shell 里面的反向选择为[!range], 正则里面是 [^range]


2扩展正则表达式

扩展正则表达式是对基础正则表达式添加了几个特殊构成的。
它令某些操作更加方便。
比如我们要去除 空白行和行首为 #的行， 会这样用：
woody@xiaoc:~/tmp$ grep -v '^$' regular_express.txt | grep -v '^#'
"Open Source" is a good mechanism to develop programs.
apple is my favorite food.
Football game is not use feet only.
this dress doesn't fit me.
............

然而使用支持扩展正则表达式的 egrep 与扩展特殊符号 | ，会方便许多。
注意grep只支持基础表达式， 而egrep 支持扩展的， 其实 egrep 是 grep -E 的别名而已。因此grep -E 支持扩展正则。
那么:
woody@xiaoc:~/tmp$ egrep -v '^$|^#' regular_express.txt 
"Open Source" is a good mechanism to develop programs.
apple is my favorite food.
Football game is not use feet only.
this dress doesn't fit me.
....................
这里| 表示或的关系。 即满足 ^$ 或者 ^# 的字符串。

这里列出几个扩展特殊符号：
＋， 于 . * 作用类似，表示 一个或多个重复字符。
?， 于 . * 作用类似，表示0个或一个字符。
｜，表示或关系，比如 'gd|good|dog' 表示有gd,good或dog的串
（），将部分内容合成一个单元组。 比如 要搜索 glad 或 good 可以这样 'g(la|oo)d'
()的好处是可以对小组使用 + ? * 等。
比如要搜索A和C开头结尾，中间有至少一个(xyz) 的串，可以这样 : 'A(xyz)+C'

如题，工程目录中有文件是utf-8格式有些是gb2312格式，使用secureCRT连接到开发机上grep中文时只能找出部分文件。

求解决方法，谢谢。

已解决，方法如下：

假设要查找字的是中文，查找到它的utf-8编码和gb2312编码分别是E4B8ADE69687和D6D0CEC4（这里可查询到）
使用grep：grep -rnP "\xE4\xB8\xAD\xE6\x96\x87|\xD6\xD0\xCE\xC4" *即可